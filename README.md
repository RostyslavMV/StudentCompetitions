# StudentCompetitions

Exam OOP Winter 2019

A program to demonstrate student competitions

Timetracking:
--------------------------------
Stage 1: Planning and predicting
--------------------------------

Understanding task - 00:40

Making base classes for inner program structure - 03:00

Designing and coding interface - 03:00

Debugging - 03:00

Sum - 09:40

Stage 2: Time Measurement (sum of all time intervals for every step)
-----------------------------------

Understanding task - 00:35

Making base classes for inner program structure - 03:48

Creating data for demonstration 00:37

Learning new features in WPF framework for interface, learning C# LINQ new functions and other 01:22

Designing and coding interface 04:39

Devugging 02:27

Sum - 13:28

Stage 3: Analysis
-----------------------------------
Hardest steps in making this task were binding to interface, because I am a beginner in WPF Framework and C# LINQ library, because I
used it not so many times before. Easiest part was making structure classes for this task, because it was a much better experience to 
code C# comparing to Module Test on C++. Interface took the most time of my work, that is because I spend a lot of time imagine layout
and had to learn some new features. Debugging was a little bit faster, than expected, that is thanks for C# :). When I was predicting time,
I did not add "Creating data for demonstration" and I did not split learning new features from other steps. I believe, that time expected was
pretty close to actual in general, but I did not predict how much time I really need to learn new features and to implement them. I have not
refactored my code and I believe, that it is normally structured for a project of this size. There were small insights in creating layout,
and when I was thinking about filter function. I believe, that I am little bit lacking of C# WPF experience, but that is natural and in the
future this kind of tasks will take me less time to do. I think, that when you try to predict time, you have to add 30% to your prediction
or even more, because there are always unexpected problems, bugs and so on.
